---
tags: 學習
---


# Ts 基础部分

## 一、JavaScript

​		任何新技术的出现（TypeScript）都是为了解决原有技术（JavaScript）的某个痛点。

​		JavaScript是一门优秀的编程语言吗？ 

- 每个人可能观点并不完全一致，但是从很多角度来看，JavaScript是一门非常优秀的编程语言； 
- 而且，可以说在很长一段时间内这个语言不会被代替，并且会在更多的领域被大家广泛使用；

​		著名的Atwood定律： 

- Stack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律。 

- any application that can be written in JavaScript, will eventually be written in JavaScript. 

  **任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现。**

​		其实我们已经看到了，这句话正在一步步被应验： 

- Web端的开发我们一直都是使用JavaScript；
- 移动端开发可以借助于ReactNative、Weex、Uniapp等框架实现跨平台开发；
- 小程序端的开发也是离不开JavaScript；
- 桌面端应用程序我们可以借助于Electron来开发； 
- 服务器端开发可以借助于Node环境使用JavaScript来开发；

### 1.2、痛点

- 随着近几年前端领域的快速发展，让JavaScript迅速被普及和受广大开发者的喜爱，借助于JavaScript本身的强大，也让使用JavaScript开发的人员越来越多。 
- 优秀的JavaScript没有缺点吗？ 
  - 其实由于各种历史因素，JavaScript语言本身存在很多的缺点； 
  - 比如ES5以及之前的使用的var关键字关于作用域的问题； 
  - 比如最初JavaScript设计的数组类型并不是连续的内存空间； 
  - 比如直到今天JavaScript也没有加入类型检测这一机制； 
- JavaScript正在慢慢变好 
  - 不可否认的是，JavaScript正在慢慢变得越来越好，无论是从底层设计还是应用层面。 
  - ES6、7、8等的推出，每次都会让这门语言更加现代、更加安全、更加方便。 
  - 但是直到今天，JavaScript在类型检测上依然是毫无进展 。

### 1.3、无类型检测带来的问题

#### 1.3.1、说明

- 首先你需要知道，编程开发中我们有一个共识：**错误出现的越早越好。**
  - 能在写代码的时候发现错误，就不要在代码编译时再发现（IDE在代码编写过程中帮助我们发现错误）。 
  - 能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测可以很好的做到这一点）。 
  - 能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要上线后发现错误。 
- 现在我们想探究的就是如何在代码编译期间 发现代码的错误： 
  - JavaScript可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题

#### 1.3.2、案例

​		代码如下所示：

```javascript
// 定义一个函数,该函数的作用是实现求数组的最大值
function getMax (arrs) {
    let max = arrs[0];
    for (let i = 1; i < arrs.length; i++){
        if (max < arrs[i]) {
            max = arrs[i];
        }
    }
    return max;
}

// 测试一: 正确调用
let result1 = getMax([10, 90, 36, 28]);
console.log(result1);

// 测试二: 会报错
let result2 = getMax();
console.log(result2);
```

​		问题总结：

- 测试一：没有问题，可以正确调用

- 测试二：会报错

  ![001](/001.png)

#### 1.3.3、TypScript实现

​		代码如下：

```typescript
// 定义一个函数,该函数的作用是实现求数组的最大值
function getMax (arrs: number[]) {
    let max = arrs[0];
    for (let i = 1; i < arrs.length; i++){
        if (max < arrs[i]) {
            max = arrs[i];
        }
    }
    return max;
}

// 测试一: 可以正确调用
let result1 = getMax([10, 90, 36, 28]);
console.log(result1);

// 测试二: 会报错
let result2 = getMax();
console.log(result2);

// 一个ts文件都是一个模块,此句的作用是用来表示这个一个模块
export { }
```

​		效果如下：

![002](/002.png)

### 1.4、类型错误

- 这是我们一个非常常见的错误： 
  - 错误的原因是因为JavaScript没有对传入的参数进行任何的限制，只能等到运行期间才发现这个错误； 
  - 当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃； 
- 当然，你可能会想：我怎么可能犯这样低级的错误呢？ 
  - 比如写像上面这样的简单的demo时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来； 
  - 但是当我们开发一个大型项目时呢？而且如果我们是调用别人的类库，又如何知道让我们传入的到底是什么样的参数呢？ 
- 实际上我们可以给JavaScript加上很多限制，在开发中就可以很好的避免这样的问题了： 
  - 比如我们的 getMax 函数中 arrs 是一个必传的参数，调用者如果没有传入则编译期间就会报错； 
  - 比如我们要求它必须是一个数组类型，传入其他类型就直接报错； 
  - 那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改；

### 1.5、类型思维的缺失

- 我们已经简单体会到没有类型检查带来的一些问题，JavaScript因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失： 
  - 前端人员通常不关心变量或者参数是什么类型的，如果在必须确定类型时往往需要使用各种判断验证； 
  - 从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮；
- 所以我们经常会说JavaScript不适合开发大型项目，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患， 并且多人员开发之间也没有良好的类型契约。 
  - 比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性； 
  - 比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要传入什么参数， 返回值是什么类型；

### 1.6、JavaScript添加类型约束

- 为了弥补JavaScript类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案： 
  - 2014年，Facebook推出了flow来对JavaScript进行类型检查； 
  - 同年，Microsoft微软也推出了TypeScript1.0版本； 
  - 他们都致力于为JavaScript提供类型检查； 
- 而现在，无疑TypeScript已经完全胜出： 
  - Vue2.x的时候采用的就是flow来做类型检查； 
  - Vue3.x已经全线转向TypeScript，98.3%使用TypeScript进行了重构； 
  - Angular在很早期就使用TypeScript进行了项目重构并且需要使用TypeScript来进行开发； 
  - 甚至Facebook公司一些自己的产品也在使用TypeScript； 
- 学习TypeScript不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。 
  - 如果之后想要学习其他语言，比如Java、C++等也会是轻车熟路；

## 二、认识TypeScript

### 2.1、概述

- 虽然知道TypeScript是干嘛的，也知道它解决了什么问题，但还是需要全面来认识下TypeScript到底是什么？ 
- TypeScript在GitHub和官方上对自己的定义： 
  - GitHub说法：TypeScript is a superset of JavaScript that compiles to clean JavaScript output. 
  - TypeScript官网：TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. 
  - 翻译一下：TypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码。 
- 怎么理解上面的话呢？ 
  - 我们可以将TypeScript理解成**加强版的JavaScript**。 
  - JavaScript所拥有的特性，TypeScript全部都是支持的，并且它紧随ECMAScript的标准，它都是支持的；
  - TypeScript在实现新特性的同时，总是保持和ES标准的同步甚至是领先； 
  - 在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型、元组类型等； 
  - TypeScript最终会被编译成JavaScript代码，所以你并不需要担心它的兼容性问题，在编译时也可以不借助于Babel这样的工具； 
- 所以，我们可以把TypeScript理解成更加强大的JavaScript，不仅让JavaScript更加安全，而且给它带来了诸多好用的好用特性。

![003](/003.png)

### 2.2、特点

- 始于JavaScript，归于JavaScript 
  - TypeScript从今天数以百万计的JavaScript开发者所熟悉的语法和语义开始； 
  - 使用现有的JavaScript代码，包括流行的JavaScript库，并从JavaScript代码中调用TypeScript代码； 
  - TypeScript可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持ECMAScript 3（或 更高版本）的JavaScript引擎中；
- TypeScript是一个强大的工具，用于构建大型项目 
  - 类型允许在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构； 
  - 类型是可选的，并且支持类型推断
- 拥有先进的 JavaScript 
  - TypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件；
  - 这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的ECMAScript3（更新新版本）的JavaScript；

### 2.3、使用场景

- Angular源码在很早就使用TypeScript来进行了重写，并且开发Angular也需要掌握TypeScript； 
- Vue3源码也采用了TypeScript进行重写，在阅读源码时你会看到大量TypeScript的语法； 
- 目前已经变成最流行的编辑器VSCode也是使用TypeScript来完成的； 
- 在React中已经使用的ant-design的UI库，也大量使用TypeScript来编写； 
- 目前公司非常流行Vue3+TypeScript、React+TypeScript的开发模式； 
- 小程序开发，也是支持TypeScript的；

### 2.4、大前端的发展趋势

- 大前端是一群最能或者说最需要折腾的开发者： 
  - 客户端开发者：从Android到iOS，或者从iOS到Android，到RN，甚至现在越来越多的客户端开发者接触前端相关知识 （Vue、React、Angular、小程序）； 
  - 前端开发者：从jQuery到AngularJS，到三大框架并行：Vue、React、Angular，还有小程序，甚至现在也要接触客户端开 发（比如RN、Flutter）；
  - 目前又面临着不仅仅学习ES的特性，还要学习TypeScript； 
  - 新框架的出现，我们又需要学习新框架的特性，比如vue3.x、react18等等； 
  - 新的工具也是层出不穷，比如vite（版本更新也很快）； 
- 但是每一样技术的出现都会有惊喜，因为他必然是解决了之前技术的某一个痛点的，而TypeScript正是解决了JavaScript存在 的很多设计缺陷，尤其是关于类型检测的。 
- 从开发者长远的角度来看，学习TypeScript有助于我们前端程序员培养类型思维，这种思维方式对于完成大型项目尤为重要。

### 2.5、HelloWorld入门案例

#### 2.5.1、代码实现

```typescript
// 声明变量的同时指定类型
// >> string: TypeScript提供的字符串类型
// >> String: JavaScript提供的字符串的包装类型
let username: string = 'HelloWorld';

console.log(username);

export { }
```

#### 2.5.2、说明

​		编写好TypeScript之后，并不能直接运行。对于TypeScript代码的运行必须要转换成 JavaScript 代码才可以。

### 2.6、TypeScript的编译环境

#### 2.6.1、说明

​		TypeScript最终会被编译成JavaScript来运行，所以我们需要搭建对应的环境。

![004](/004.png)

#### 2.6.2、具体做法

​		需要在电脑上安装TypeScript，这样就可以通过TypeScript的Compiler将其编译成JavaScript；

​		全局安装：

```shell
# 安装命令
npm install typescript -g

# 查看版本
tsc --version
```

#### 2.6.3、编译HelloWorld.ts程序

```shell
# 编译
tsc 03-HelloWorld入门案例.ts
```

![005](/005.png)

#### 2.6.4、运行

​		生成的HelloWorld.js 代码如下所示：

```javascript
"use strict";
exports.__esModule = true;

// 声明变量的同时指定类型
// >> string: TypeScript提供的字符串类型
// >> String: JavaScript提供的字符串的包装类型
var username = 'HelloWorld';
console.log(username);

```

​		在浏览器端运行 HelloWorld.js 代码。

> 注意：HelloWorld.js 代码中的 exports.__esModule = true; 代码要删除。

### 2.7、TypeScript的运行环境

#### 2.7.1、说明

- 如果我们每次为了查看TypeScript代码的运行效果，都通过这两个步骤的话就太繁琐了： 
  - 第一步：通过tsc编译TypeScript到JavaScript代码； 
  - 第二步：在浏览器或者Node环境下运行JavaScript代码； 
- 是否可以简化这样的步骤呢？ 
  - 比如编写了TypeScript之后可以直接运行在浏览器上？ 
  - 比如编写了TypeScript之后，直接通过node的命令来执行？ 
- 上面提到的两种方式，可以通过两个解决方案来完成： 
  - 方式一：通过webpack，配置本地的TypeScript编译环境和开启一个本地服务，直接运行在浏览器上； 
  - 方式二：通过ts-node库，为TypeScript的运行提供执行环境；

#### 2.7.2、具体做法

​		安装ts-node：

```shell
# 安装 ts-node
npm install ts-node -g

# 要注意的是：ts-node需要依赖 tslib 和 @types/node 两个包
npm install tslib @types/node -g
```

​		运行：

```shell
# 直接通过 ts-node 运行 TypeScript 代码
ts-node 03-HelloWorld入门案例.ts
```

​		效果如下：

![006](/006.png)

## 三、变量

### 3.1、说明

- 在TypeScript中定义变量需要指定 标识符 的类型。

- 声明了类型后TypeScript就会进行**类型检测**，声明的类型可以称之为**类型注解（Type Annotation）**

  ```shell
  # 语法
  var/let/const 标识符: 数据类型 = 值;
  
  # 案例
  let username: string = 'HelloWorld';
  
  # 注意: string是TypeScript中定义的字符串类型，String是ECMAScript中定义的一个类
  ```

- 如果给 username 赋值其他类型，则会直接报错。

  ![007](/007.png)

### 3.2、声明变量关键字

- 在TypeScript定义变量（标识符）和ES6之后一致，可以使用var、let、const来定义。
- 不推荐使用 var 关键字声明变量。

### 3.3、变量的类型推导

- 变量的类型推导又叫做类型推断

- 在开发中为了方便并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过TypeScript本身的 特性帮助我们推断出对应的变量类型。

  ![008](/008.png)

- 这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型。

## 四、数据类型

### 4.1、说明

​		TypeScript是JavaScript的一个超级。

![009](/009.png)

### 4.2、number类型

#### 4.2.1、说明

​		TypeScript和JavaScript一样，不区分整数类型（int）和浮点型（double），统一为 number类型。

#### 4.2.2、案例

```typescript
let total = 80;

console.log(total);

export { }
```

### 4.3、boolean类型

#### 4.3.1、说明

​		boolean类型只有两个取值：true和false。

#### 4.3.2、案例

```typescript
let flag: boolean = true;

console.log(flag);

export { }
```

### 4.4、string类型

### 4.4.1、说明

​		string类型是字符串类型，可以使用单引号或者双引号表示。

​		同时也支持ES6的模板字符串来拼接变量和字符串。

### 4.4.2、案例

```typescript
let username: string = 'HelloWorld';
console.log(username);

console.log('-----------------');

const name = '小军';
const age = 23;
const address = '郑州市';
const info = `名字是${name}:,年龄是${age},家庭地址是:${address}`;

console.log(info);

export { }
```

## 4.5、Array类型

### 4.5.1、说明

​		数组类型的定义有两种方式：

- string[]
- Array<string>
  - 这种方式属于泛型的写法

### 4.5.2、案例1

```typescript
// 定义一个只能存储字符串类型的数组
const usernames:string[] = ['小军', '小马', '小红'];

usernames.push('Hello');

console.log(usernames);

export { }
```

### 4.5.3、案例2

```typescript
// 定义一个只能存储字符串类型的数组
const usernames:Array<string> = ['小军', '小马', '小红'];

usernames.push('Hello');

console.log(usernames);

export { }
```

### 4.5.4、注意

![010](/010.png)

## 4.6、Object类型

### 4.6.1、说明

​		object对象类型可以用于描述一个对象。

### 4.6.2、问题案例

​		一般去定义对象类型时，可能会这么写，代码如下：

```typescript
const user: object = {
    username: '小军',
    age: 21
}

console.log(user.username);
console.log(user.age);

export { }
```

![011](/011.png)

### 4.6.3、正确写法

```typescript
const user: {
    username: string,
    age: number
} = {
    username: '小军',
    age: 21
}

console.log(user.username);
console.log(user.age);

export { }
```

### 4.6.4、改进写法

```typescript
// 定义对象类型
type UserObj = {
    username: string,
    age: number
}

// 创建对象的同时指定类型
const user: UserObj = {
    username: '小军',
    age: 21
}

console.log(user.username);
console.log(user.age);

export { }
```

## 4.7、null和undefined类型

### 4.7.1、说明

- 在 JavaScript 中，undefined 和 null 是两个基本数据类型。
- 在TypeScript中，它们各自的类型也是undefined和null，也就意味着它们既是实际的值，也是自己的类型。

### 4.7.2、案例

```typescript
let obj: null = null;

let username: undefined = undefined;

console.log(obj);
console.log(username);
```

## 4.8、函数的参数类型

### 4.8.1、说明

​		函数是JavaScript非常重要的组成部分，TypeScript允许我们指定函数的参数类型。

### 4.8.2、案例

​		参数的类型注解： 声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型。

​		代码如下：

```typescript
function info (username: string, age: number) {
    let result = `姓名是:${username.toUpperCase()},年龄是:${age}`;
    console.log(result);
}

info('Hello', 21);

export { }
```

> 总结：
>
> 1. 对函数的参数进行了类型指定，那么在编译阶段，就可以直接调用该类型身上的方法。
>
>      		2. 在定义一个TypeScript中的函数时, 都要明确的必须指定参数的类型，并且不会进行类型推导。
>      		3. 如果函数的参数不指定类型，那么就是 any 类型（任意类型）。

### 4.8.3、注意

![012](/012.png)

## 4.9、函数的返回值类型

### 4.9.1、说明

​		TypeScript允许我们指定函数的返回值的类型，这个类型注解出现在函数列表的后面。

### 4.9.2、案例

​		代码如下：

```typescript
function info (username: string, age: number): string {
    let result = `姓名是:${username.toUpperCase()},年龄是:${age}`;

    return result;
}

let res = info('Hello', 23);
console.log(res);

export { }
```

> 总结：
>
> 		1.  通常情况下不需要返回类型注解，因为TypeScript会根据 return 返回值推断函数的返回类型。
>   		2.  某些第三方库处于方便理解，会明确指定返回类型。
>                 		3.  定义一个TypeScript中的函数时返回值类型可以明确的指定, 也可以自动进行类型推导

## 4.10、匿名函数的参数

### 4.10.1、说明

​		匿名函数与函数声明会有一些不同，当一个函数出现在TypeScript可以确定该函数会被如何调用的地方时，该函数的参数会自动指定类型。

### 4.10.2、案例

​		代码如下：

```typescript
const usernames = ['Hello', 'Spring', 'Summer', 'Winter'];

// 匿名函数的参数 item 会自动进行类型推断,为字符串类型
usernames.forEach(function (item) {
    console.log(item.toUpperCase());
})
```

> 总结：
>
> 1. 并没有指定item的类型，但是item是一个string类型
>
>      		2. TypeScript会根据forEach函数的类型以及数组的类型推断出item的类型。
>      		3. 这个过程称之为上下文类型，因为函数执行的上下文可以帮助确定参数和返回值的类型。
>      		4. 匿名函数是否需要添加类型注解呢? 最好不要添加类型注解。

# 五、数据类型的其他使用

## 5.1、对象类型

### 5.1.1、说明

​		如果我们希望限定一个函数接受的参数是一个对象，这个时候要如何限定呢？此时就可以使用对象类型。

### 5.1.2、案例

​		代码如下：

```typescript
function printObj (user: {username:string,age:number }) {
    console.log('姓名是:' + user.username);
    console.log('年龄是:' + user.age);
}

printObj({ username: 'HelloWorld', age: 21 });

export { }
```

### 5.1.3、写法改进

​		代码如下：

```typescript
// 定义对象类型
type UserType = {
    username: string,
    age: number
}

function printObj (user: UserType) {
    console.log('姓名是:' + user.username);
    console.log('年龄是:' + user.age);
}

printObj({ username: 'HelloWorld', age: 21 });

export { }
```

> 总结：
>
> 	1. 在对象我们可以添加属性，并且告知TypeScript该属性需要是什么类型； 
>  	2. 属性之间可以使用 , 或者 ; 来分割，最后一个分隔符是可选的； 
>  	3. 每个属性的类型部分也是可选的，如果不指定，那么就是any类型；

## 5.2、可选类型

### 5.2.1、说明

​		在指定对象类型时候，默认情况下，对象中的属性定义的有哪些，那么构造对象时就需要哪些属性。如下：

![013](/013.png)

​	如果对象中的某些属性是可选的，该如何指定呢？

​	此时就需要在属性的后面添加一个：“?” 号。

### 5.2.2、案例

​		代码如下：

```typescript
// 定义对象类型
type UserType = {
    username: string,
    age: number,
    address?: string
}

function printObj (user: UserType) {
    console.log('姓名是:' + user.username);
    console.log('年龄是:' + user.age);
}

printObj({ username: 'HelloWorld', age: 21 });

export { }
```

​		注意1，对于可选类型来说，address对象 有可能是为空，此时可以加上 ？ 

```typescript
// 定义对象类型
type UserType = {
    username: string,
    age: number,
    address?: {
        name: string
    }
}

function printObj (user: UserType) {
    console.log('姓名是:' + user.username);
    console.log('年龄是:' + user.age);
    console.log('地址是:' + user.address?.name);
}

printObj({ username: 'HelloWorld', age: 21 });

export { }
```

​		注意2：可选类型在使用属性时,只能获取值，不能赋值，此时语法是错误的。下面的代码是错误的。

```typescript
type UserType = {
    username: string,
    age: number,
    address?: {
        name: string
    }
}

function printObj (user: UserType) {
    console.log('姓名是:' + user.username);
    console.log('年龄是:' + user.age);

    // 可选类型在使用属性时,只能获取值，不能赋值，此时语法是错误的
    user.address?.name = '郑州市';
    console.log('地址是:' + user.address?.name);
}

printObj({ username: 'HelloWorld', age: 21});

export { }
```

## 5.3、any类型

### 5.3.1、说明

​		在某些情况下，确实无法确定一个变量的类型，并且可能它会发生变化，这个时候我们可以使用any类型。

​		any类型有点像一种讨巧的TypeScript手段： 

- 可以对any类型的变量进行任何的操作，包括获取不存在的属性、方法； 
- 给一个any类型的变量赋值任何的值，比如数字、字符串的值

​		对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候我们可以使用any，在Vue源码中，也会使用到any来进行某些类型的适配。

### 5.3.2、案例

​		代码如下：

```typescript
let message: any = '今天天气很晴朗';

message = '小军';
message = 34;

let arrs: any[] = ['小李',123];

export { }
```

> 总结：
>
> 		1. any类型就表示不限制标识符的任意类型, 并且可以在该标识符上面进行任意的操作
>
>   		2. 在TypeScript中回到JavaScript中。

## 5.4、unknown类型

### 5.4.1、说明

​		unknown是TypeScript中比较特殊的一种类型，它用于描述类型不确定的变量。

​		和any类型有点类似，但是unknown类型的值上做任何事情都是不合法的。

### 5.4.2、问题案例

![014](/014.png)

### 5.4.3、解决

​		代码如下：

```typescript
let message: unknown = '今天天气很晴朗';

// unknown类型默认情况下在上面进行任意的操作都是非法的\
// 要求必须进行类型的校验(缩小), 才能根据缩小之后的类型, 进行对应的操作
if (typeof message === 'string') {
    console.log(message.length);
}

export { }
```

> 总结：
>
> 	1. unknown类型默认情况下在上面进行任意的操作都是非法的
>
>  	2. 必须进行类型的校验，类型缩小，才能根据缩小之后的类型，进行对应的操作。

## 5.5、void类型

### 5.5.1、说明

​		void通常用来指定一个函数是没有返回值的，那么它的返回值就是void类型。

### 5.5.2、案例1

​		代码如下：

```typescript
function sum (num1: number , num2: number) {
    let result = num1 + num2;
    console.log('两个数的和是:' + result);
}
export { }
```

​		上述代码等同于：

```typescript
function sum (num1: number , num2: number): void {
    let result = num1 + num2;
    console.log('两个数的和是:' + result);
}
export { }
```

> 这个函数没有写任何类型，那么它默认返回值的类型就是void的，我们也可以显示的来指定返回值是void

### 5.5.3、案例2

​		代码如下：

```typescript
function sum (num1: number , num2: number): void {
    let result = num1 + num2;
    console.log('两个数的和是:' + result);

    return undefined;
}
export { }
```

> 可以将undefined赋值给void类型，也就是函数可以返回undefined

### 5.5.4、应用场景

​		用来指定函数类型的返回值是 void 。

​		代码如下：

```typescript
// 应用场景: 用来指定函数类型的返回值是void
type FnType = () => void;
const info: FnType = () => {
    console.log('void类型的应用');
}

info();

export { }
```

### 5.5.5、应用案例

​		需求：定义一个函数A，该函数的参数接收一个函数B，A函数的作用是执行B函数。

```typescript
// 1、定义A函数接收的参数函数的类型，就是参数是一个函数，也要定义函数类型
type FnType = (...args: any[]) => void;

// 2、定义A函数,接收一个参数B，B是一个函数,而且B函数的数据类型必须是FnType
function A (B: FnType) {
    setTimeout(() => {
        B('小军',20)
    },1000);
}

// 3、调用A函数
A(function (username, age) {
    console.log(`姓名是:${username},年龄是:${age}`);
});

export { }
```

### 5.5.6、补充

​		基于上下文类型推导的函数中的返回值如果是void类型, 并且不强制要求不能返回任何的东西。

​		代码1如下：

```typescript
type FnType = () => void;

// foo 的值是一个函数类型，但是该函数类型的返回值是void。
// 所以通过上下文推导出返回类型是void,但是并不会强制函数一定不能返回其他值
const foo: FnType = () => {
    return 123;
}

export { }
```

​		代码2如下：

```typescript
const names = ['小军', '小红', '小李'];

// forEach接收的匿名函数其实不需要有返回值,其实也是可以有返回值的。
names.forEach(item => {
    console.log(item);
    return 'ok';
});

export { }
```

![015](/015.png)

## 5.6、never类型

### 5.6.1、说明

​		never 表示永远不会发生值的类型，比如一个函数：

- 如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗？
- 不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型；

### 5.6.2、案例

​		代码如下：

```typescript
function info (): never {
    while (true) {
        console.log('死循环');
    }
}

info();

function run () {
    return [];
}

run();

export { }
```

> 实际开发中，我们自己很少写 never 类型。

## 5.7、tuple类型

### 5.7.1、说明

​		tuple是元组类型，和数组非常像，都是可以存储多个数据。不同之处在于：

- 数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中
- 元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型

### 5.7.2、需求

​		保存一个人的信息，包括：用户名、年龄、家庭地址。

​		方式一：使用数组类型，代码如下：

```typescript
const userinfo = ['小军', 20, '郑州市'];

const age = userinfo[1];

console.log(age);

export { }
```

```markdown
# 使用数组类型不合适, 数组中最好存放相同的数据类型, 获取值之后不能明确的知道对应的数据类型
```

​		方式二：使用对象类型，代码如下：

```typescript
// 使用对象类型
const userinfo2 = {
    username: '小军',
    age: 20,
    address: '郑州市'
}

console.log(userinfo2.age);

export { }
```

```markdown
# 使用最多的方式
```

### 5.7.3、元组方式实现

​		代码实现如下：

```typescript
// 使用元组方式实现
// >> 元组数据类型结构中可以存放不同的数据类型,取出来的元素也具有明确的类型
const userinfo3: [string, number, string] = ['小军', 20, '郑州市'];

// >> 具有明确的类型
let username = userinfo3[0];
console.log(username);

export { }
```

### 5.7.4、元组的使用场景

​		tuple通常可以作为返回的值，在使用的时候会非常的方便；

```typescript
// 元组的应用场景
function useState (initState: number) : [number, (newValue: number) => void]{
    // 赋值
    let count = initState;
    // 定义操作状态的方法
    function setCount (newValue: number) {
        count = newValue;
    }
    return [count,setCount]
}

const [count, setCount] = useState(10);
console.log(count);
setCount(200);

export { }
```

